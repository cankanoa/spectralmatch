{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"spectralmatch: A toolkit for performing Relative Radiometric Normalization, with utilities for generating seamlines, cloud masks, Pseudo-Invariant Features, and statistics","text":"<p>[!IMPORTANT] This library is experimental and still under heavy development.</p>"},{"location":"#overview","title":"Overview","text":"<p>spectralmatch provides a Python library and QGIS plugin with multiple algorythms to perform Relative Radiometric Normalization (RRN). It also includes utilities for generating seamlines, cloud masks, Pseudo-Invariant Features, statistics, preprocessing, and more.</p>"},{"location":"#features","title":"Features","text":"<ul> <li> <p>Automated: Works without manual intervention, making it ideal for large-scale applications.</p> </li> <li> <p>Consistent Multi-Image Analysis: Ensures uniformity across images by applying systematic corrections with minimal spectral distortion.</p> </li> <li> <p>Seamlessly Blended: Creates smooth transitions between images without visible seams.</p> </li> <li> <p>Unit Agnostic: Works with any pixel unit and preserves the spectral information for accurate analysis. This inlcludes negative numbers and reflectance.</p> </li> <li> <p>Better Input for Machine Learning Models: Provides high-quality, unbiased data for AI and analytical workflows.</p> </li> <li> <p>Minimizes Color Bias: Avoids excessive color normalization and does not rely on a strict reference image.</p> </li> <li> <p>Sensor Agnostic: Works with all optical sensors. In addition, images from differnt sensors can be combined for multisensor analysis.</p> </li> <li> <p>Parallel Processing: Optimized for modern CPUs to handle large datasets efficiently.</p> </li> <li> <p>Large-Scale Mosaics: Designed to process and blend vast image collections effectively.</p> </li> <li>Time Series: Normalize images across time with to compare spectral changes.</li> </ul>"},{"location":"#current-matching-algorithms","title":"Current Matching Algorithms","text":""},{"location":"#global-to-local-matching","title":"Global to local matching","text":"<p>This technique is derived from 'An auto-adapting global-to-local color balancing method for optical imagery mosaic' by Yu et al., 2017 (DOI: 10.1016/j.isprsjprs.2017.08.002). It is particularly useful for very high-resolution imagery (satellite or otherwise) and works in a two phase process. First, this method applies least squares regression to estimate scale and offset parameters that align the histograms of all images toward a shared spectral center. This is achieved by constructing a global model based on the overlapping areas of adjacent images, where the spectral relationships are defined. This global model ensures that each image conforms to a consistent radiometric baseline while preserving overall color fidelity. However, global correction alone cannot capture intra-image variability so a second local adjustment phase is performed. The overlap areas are divided into smaller blocks, and each block\u2019s mean is used to fine-tune the color correction. This block-wise tuning helps maintain local contrast and reduces visible seams, resulting in seamless and spectrally consistent mosaics with minimal distortion.</p> <p> Shows the average spectral profile of two WorldView 3 images before and after global to local matching.</p>"},{"location":"#assumptions","title":"Assumptions","text":"<ul> <li> <p>Consistent Spectral Profile: The true spectral response of overlapping areas remains the same throughout the images.</p> </li> <li> <p>Least Squares Modeling: A least squares approach can effectively model and fit all images' spectral profiles.</p> </li> <li> <p>Scale and Offset Adjustment: Applying scale and offset corrections can effectively harmonize images.</p> </li> <li> <p>Minimized Color Differences: The best color correction is achieved when color differences are minimized.</p> </li> <li> <p>Geometric Alignment: Images are assumed to be geometrically aligned with known relative positions.</p> </li> <li> <p>Global Consistency: Overlapping color differences are consistent across the entire image.</p> </li> <li> <p>Local Adjustments: Block-level color differences result from the global application of adjustments.</p> </li> </ul>"},{"location":"#installation-with-pypi-and-use-as-a-python-library","title":"Installation with Pypi and use as a Python Library","text":""},{"location":"#1-system-requirements","title":"1. System requirements","text":"<p>Before installing, ensure you have the following system-level prerequisites:</p> <ul> <li>Python \u2265 3.10</li> <li>PROJ \u2265 9.3</li> <li>GDAL \u2265 3.6</li> </ul> <p>An easy way to install these dependancies is to use Miniconda: <pre><code>conda create -n spectralmatch python&gt;=3.10 gdal&gt;=3.6 proj&gt;=9.3 -c conda-forge\nconda activate spectralmatch\n</code></pre></p>"},{"location":"#2-install-spectralmatch-via-pypi-or-source","title":"2. Install spectralmatch (via PyPI or Source)","text":"<p>The recommended way to install is via PyPI. (this method installs only the core code as a library):</p> <pre><code>pip install spectralmatch\n</code></pre> <p>Another install method is to clone the repository and confugure the dependancies with <code>pyproject.toml</code>. (this method installs the whole repository for development or customization):</p> <pre><code>git clone https://github.com/spectralmatch/spectralmatch.git\ncd spectralmatch\npip install .\n</code></pre>"},{"location":"#3-run-example-code-and-modify-for-use-optional","title":"3. Run example code and modify for use (optional)","text":"<p>Example scripts are provided to verify a successful installation and help you get started quickly at <code>/docs/examples</code></p>"},{"location":"#install-and-use-as-a-qgis-plugin","title":"Install and use as a QGIS Plugin","text":""},{"location":"#1-download-and-install-qgis","title":"1. Download and install QGIS","text":""},{"location":"#2-open-qgis","title":"2.  Open QGIS","text":""},{"location":"#3-go-to-plugins-manage-and-install-plugins","title":"3.  Go to Plugins \u2192 Manage and Install Plugins\u2026","text":""},{"location":"#4-find-spectralmatch-in-the-list-install-and-enable-it","title":"4.  Find spectralmatch in the list, install, and enable it","text":""},{"location":"#5-find-the-plugin-in-the-processing-toolbox","title":"5.  Find the plugin in the Processing Toolbox","text":""},{"location":"#documentation","title":"Documentation","text":"<p>Documentation is available at spectralmatch.github.io/spectralmatch/.</p>"},{"location":"#contributing-guide","title":"Contributing Guide","text":"<p>We welcome all contributions the project! To get started: 1. Create an issue with the appropriate label describing the feature or improvement. Provide relevant context, desired timeline, any assistance needed, who will be responsible for the work, anticipated results, and any other details. 2. Fork the repository and create a new feature branch. 3. Make your changes and add any necessary tests. 4. Open a Pull Request against the main repository.</p>"},{"location":"#developer-guide","title":"Developer Guide","text":"<ol> <li> <p>Clone the Repository <pre><code>git clone https://github.com/spectralmatch/spectralmatch.git\ncd spectralmatch\n</code></pre></p> </li> <li> <p>Install with Dev andor Docs Extras</p> </li> </ol> <p>There are additional <code>[dev]</code> and <code>[docs]</code> dependancies specified in <code>pyproject.toml</code>:</p> <pre><code>pip install -e \".[dev]\"   # for developer dependencies\npip install -e \".[docs]\"  # for documentation dependencies\n</code></pre> <ol> <li>Set Up Pre-commit Hooks</li> </ol> <p>To maintain code consistency before each commit install these hooks:</p> <pre><code>pre-commit install\npre-commit run --all-files\n</code></pre>"},{"location":"#testing","title":"Testing","text":"<p>pytest is used for testing. Tests will automatically be run when merging into main but they can also be run locally via:</p> <pre><code>pytest\n</code></pre> <p>Run tests for a specific file or function:</p> <pre><code>pytest folder/file.py\n</code></pre>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License. See LICENSE for details.</p>"},{"location":"development/","title":"Development Guide","text":"<p>This project provides this Makefile to streamline development tasks. Makefiles allow you to automate and organize common tasks, in this case to help you serve and deploy documentation, manage version tags, format and lint code, and run tests.</p> <p>Installation instructions are on their own page</p>"},{"location":"development/#docs","title":"Docs","text":""},{"location":"development/#serve-docs-locally","title":"Serve docs locally","text":"<p>Runs a local dev server at http://localhost:8000. <pre><code>make docs-serve\n</code></pre></p>"},{"location":"development/#build-static-site","title":"Build static site","text":"<p>Generates the static site into the site/ folder.</p> <pre><code>make docs-build\n</code></pre>"},{"location":"development/#deploy-to-github-pages","title":"Deploy to GitHub Pages","text":"<p>Deploys built site using mkdocs gh-deploy. <pre><code>make docs-deploy\n</code></pre></p>"},{"location":"development/#versioning","title":"Versioning","text":"<p>Uses git tag to create annotated version tags and push them. <pre><code>make tag version=1.2.3\n</code></pre></p>"},{"location":"development/#code-formatting","title":"Code Formatting","text":"<p>Uses black for code formatting and ruff for linting.</p>"},{"location":"development/#format-code","title":"Format code","text":"<p>Automatically formats all Python files with black. <pre><code>make format\n</code></pre></p>"},{"location":"development/#check-formatting","title":"Check formatting","text":"<p>Checks that all code is formatted (non-zero exit code if not). <pre><code>make check-format\n</code></pre></p>"},{"location":"development/#lint-code","title":"Lint code","text":"<p>Runs ruff to catch style and quality issues. <pre><code>make lint\n</code></pre></p>"},{"location":"development/#testing","title":"Testing","text":"<p>Uses pytest to run the test suite. <pre><code>make test\n</code></pre></p>"},{"location":"installation/","title":"Installation Methods","text":""},{"location":"installation/#install-and-use-as-a-qgis-plugin","title":"Install and use as a QGIS Plugin","text":""},{"location":"installation/#1-download-and-install-qgis","title":"1. Download and install QGIS","text":""},{"location":"installation/#2-open-qgis","title":"2.  Open QGIS","text":""},{"location":"installation/#3-go-to-plugins-manage-and-install-plugins","title":"3.  Go to Plugins \u2192 Manage and Install Plugins\u2026","text":""},{"location":"installation/#4-find-spectralmatch-in-the-list-install-and-enable-it","title":"4.  Find spectralmatch in the list, install, and enable it","text":""},{"location":"installation/#5-find-the-plugin-in-the-processing-toolbox","title":"5.  Find the plugin in the Processing Toolbox","text":""},{"location":"installation/#installation-with-pypi-and-use-as-a-python-library","title":"Installation with Pypi and use as a Python Library","text":""},{"location":"installation/#1-system-requirements","title":"1. System requirements","text":"<p>Before installing, ensure you have the following system-level prerequisites:</p> <ul> <li>Python \u2265 3.10</li> <li>PROJ \u2265 9.3</li> <li>GDAL \u2265 3.6</li> </ul> <p>An easy way to install these dependancies is to use Miniconda: <pre><code>conda create -n spectralmatch python&gt;=3.10 gdal&gt;=3.6 proj&gt;=9.3 -c conda-forge\nconda activate spectralmatch\n</code></pre></p>"},{"location":"installation/#2-install-spectralmatch-via-pypi-or-source","title":"2. Install spectralmatch (via PyPI or Source)","text":"<p>The recommended way to install is via PyPI. (this method installs only the core code as a library):</p> <pre><code>pip install spectralmatch\n</code></pre> <p>Another install method is to clone the repository and confugure the dependancies with <code>pyproject.toml</code>. (this method installs the whole repository for development or customization):</p> <pre><code>git clone https://github.com/spectralmatch/spectralmatch.git\ncd spectralmatch\npip install .\n</code></pre>"},{"location":"installation/#3-run-example-code-and-modify-for-use-optional","title":"3. Run example code and modify for use (optional)","text":"<p>Example scripts are provided to verify a successful installation and help you get started quickly at <code>/docs/examples</code></p>"},{"location":"api/handlers/","title":"Data Handlers for IO","text":""},{"location":"api/handlers/#spectralmatch.handlers.align_rasters","title":"<code>align_rasters(input_image_paths, resample_method='bilinear', tap=True)</code>","text":"<p>Aligns a list of rasters to a common grid using the highest input resolution.</p> <p>Parameters:</p> Name Type Description Default <code>input_image_paths</code> <code>list[str]</code> <p>List of input raster file paths.</p> required <code>resample_method</code> <code>str</code> <p>Resampling method (e.g., \"bilinear\", \"nearest\", \"average\"). Defaults to \"bilinear\".</p> <code>'bilinear'</code> <code>tap</code> <code>bool</code> <p>Align to target-aligned pixels (TAP). Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of file paths to the aligned raster outputs (in a temporary directory).</p> Source code in <code>spectralmatch/handlers.py</code> <pre><code>def align_rasters(\n    input_image_paths: list[str],\n    resample_method: Literal[\"nearest\", \"bilinear\", \"cubic\", \"average\", \"mode\", \"max\", \"min\", \"med\", \"q1\", \"q3\"] = \"bilinear\",\n    tap: bool = True,\n    ) -&gt; list[str]:\n    \"\"\"\n    Aligns a list of rasters to a common grid using the highest input resolution.\n\n    Args:\n        input_image_paths (list[str]): List of input raster file paths.\n        resample_method (str, optional): Resampling method (e.g., \"bilinear\", \"nearest\", \"average\"). Defaults to \"bilinear\".\n        tap (bool, optional): Align to target-aligned pixels (TAP). Defaults to True.\n\n    Returns:\n        list[str]: List of file paths to the aligned raster outputs (in a temporary directory).\n    \"\"\"\n\n    temp_dir = tempfile.mkdtemp()  # Persistent temp directory\n    aligned_paths = []\n\n    # 1. Determine highest resolution\n    best_resolution = float(\"inf\")\n    for path in input_image_paths:\n        with rasterio.open(path) as src:\n            res = min(abs(src.transform.a), abs(src.transform.e))\n            if res &lt; best_resolution:\n                best_resolution = res\n    target_res = (best_resolution, best_resolution)\n\n    # 2. Reproject each image to its own aligned grid using target resolution\n    for path in input_image_paths:\n        filename = os.path.basename(path)\n        output_path = os.path.join(temp_dir, filename)\n\n        with rasterio.open(path) as src:\n            dst_crs = src.crs\n            transform = src.transform\n            width = src.width\n            height = src.height\n\n            if tap:\n                dst_transform, dst_width, dst_height = aligned_target(\n                    transform, width, height, target_res\n                )\n            else:\n                dst_transform, dst_width, dst_height = transform, width, height\n\n            profile = src.profile.copy()\n            profile.update({\n                \"transform\": dst_transform,\n                \"width\": dst_width,\n                \"height\": dst_height,\n                \"crs\": dst_crs,\n            })\n\n            with rasterio.open(output_path, \"w\", **profile) as dst:\n                for i in range(1, src.count + 1):\n                    reproject(\n                        source=rasterio.band(src, i),\n                        destination=rasterio.band(dst, i),\n                        src_transform=transform,\n                        src_crs=src.crs,\n                        dst_transform=dst_transform,\n                        dst_crs=dst_crs,\n                        resampling=getattr(Resampling, resample_method),\n                    )\n\n        aligned_paths.append(output_path)\n\n    return aligned_paths\n</code></pre>"},{"location":"api/handlers/#spectralmatch.handlers.merge_rasters","title":"<code>merge_rasters(data_in, data_out, resampling_method='nearest', tap=False, resolution='highest', tile_width_and_height_tuple=None, debug_mode=False)</code>","text":"<p>Merges multiple raster files into a single output mosaic with optional resampling and tiling.</p> <p>Parameters:</p> Name Type Description Default <code>data_in</code> <code>list</code> <p>List of input raster file paths.</p> required <code>data_out</code> <code>str</code> <p>Output raster file path.</p> required <code>resampling_method</code> <code>Literal['nearest', 'bilinear', 'cubic']</code> <p>Resampling method. Defaults to \"nearest\".</p> <code>'nearest'</code> <code>tap</code> <code>bool</code> <p>Align output bounds to target-aligned pixels. Defaults to False.</p> <code>False</code> <code>resolution</code> <code>Literal['highest', 'lowest']</code> <p>Use resolution of highest or lowest input. Defaults to \"highest\".</p> <code>'highest'</code> <code>tile_width_and_height_tuple</code> <code>tuple[int, int]</code> <p>Tile size for block-wise processing. Defaults to None.</p> <code>None</code> <code>debug_mode</code> <code>bool</code> <p>If True, prints debug messages. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>None</p> Outputs <p>Saves a merged GeoTIFF raster to the specified path.</p> Source code in <code>spectralmatch/handlers.py</code> <pre><code>def merge_rasters(\n    data_in: list,\n    data_out: str,\n    resampling_method: Literal[\"nearest\", \"bilinear\", \"cubic\"] = \"nearest\",\n    tap: bool = False,\n    resolution: Literal[\"highest\", \"lowest\"] = \"highest\",\n    tile_width_and_height_tuple: Optional[Tuple[int, int]] = None,\n    debug_mode: bool = False,\n    ):\n    \"\"\"\n    Merges multiple raster files into a single output mosaic with optional resampling and tiling.\n\n    Args:\n        data_in (list): List of input raster file paths.\n        data_out (str): Output raster file path.\n        resampling_method (Literal[\"nearest\", \"bilinear\", \"cubic\"], optional): Resampling method. Defaults to \"nearest\".\n        tap (bool, optional): Align output bounds to target-aligned pixels. Defaults to False.\n        resolution (Literal[\"highest\", \"lowest\"], optional): Use resolution of highest or lowest input. Defaults to \"highest\".\n        tile_width_and_height_tuple (tuple[int, int], optional): Tile size for block-wise processing. Defaults to None.\n        debug_mode (bool, optional): If True, prints debug messages. Defaults to False.\n\n    Returns:\n        None\n\n    Outputs:\n        Saves a merged GeoTIFF raster to the specified path.\n    \"\"\"\n\n    if not os.path.exists(os.path.dirname(data_out)): os.makedirs(os.path.dirname(data_out))\n\n    srcs = [rasterio.open(path) for path in data_in]\n    resampling_enum = {\"nearest\": Resampling.nearest, \"bilinear\": Resampling.bilinear, \"cubic\": Resampling.cubic}[resampling_method]\n\n    # Determine target resolution\n    all_resolutions = [src.res for src in srcs]\n    if resolution == \"highest\":\n        target_res = min(all_resolutions, key=lambda r: r[0] * r[1])\n    elif resolution == \"lowest\":\n        target_res = max(all_resolutions, key=lambda r: r[0] * r[1])\n    else:\n        raise ValueError(\"resolution must be 'highest' or 'lowest'\")\n\n    pixel_width, pixel_height = target_res\n\n    # Compute bounds of the output mosaic\n    lefts, bottoms, rights, tops = zip(*[src.bounds for src in srcs])\n    minx, miny, maxx, maxy = min(lefts), min(bottoms), max(rights), max(tops)\n\n    if tap:\n        minx = np.floor(minx / pixel_width) * pixel_width\n        maxx = np.ceil(maxx / pixel_width) * pixel_width\n        miny = np.floor(miny / abs(pixel_height)) * abs(pixel_height)\n        maxy = np.ceil(maxy / abs(pixel_height)) * abs(pixel_height)\n\n    width = int(np.round((maxx - minx) / pixel_width))\n    height = int(np.round((maxy - miny) / abs(pixel_height)))\n    out_transform = from_bounds(minx, miny, maxx, maxy, width, height)\n\n    out_crs = srcs[0].crs\n    nodata = srcs[0].nodata\n    num_bands = srcs[0].count\n    dtype = srcs[0].dtypes[0]\n\n    out_meta = {\n        \"driver\": \"GTiff\",\n        \"count\": num_bands,\n        \"dtype\": dtype,\n        \"nodata\": nodata,\n        \"width\": width,\n        \"height\": height,\n        \"transform\": out_transform,\n        \"crs\": out_crs\n    }\n\n    with rasterio.open(data_out, \"w\", **out_meta) as data_out:\n        if tile_width_and_height_tuple:\n            windows = _create_windows(width, height, *tile_width_and_height_tuple)\n        else:\n            windows = [Window(0, 0, width, height)]\n\n        for window in windows:\n            dst_array = np.full((num_bands, int(window.height), int(window.width)), nodata, dtype=dtype)\n\n            for src in srcs:\n                for b in range(1, num_bands + 1):\n                    temp = np.full((int(window.height), int(window.width)), nodata, dtype=dtype)\n                    reproject(\n                        source=rasterio.band(src, b),\n                        destination=temp,\n                        src_transform=src.transform,\n                        src_crs=src.crs,\n                        dst_transform=rasterio.windows.transform(window, out_transform),\n                        dst_crs=out_crs,\n                        dst_nodata=nodata,\n                        resampling=resampling_enum\n                    )\n                    # Only replace where temp is not nodata\n                    mask = temp != nodata\n                    dst_array[b - 1][mask] = temp[mask]\n\n            data_out.write(dst_array, window=window)\n\n    if debug_mode: print(f\"Merged raster saved to: {data_out}\")\n</code></pre>"},{"location":"api/handlers/#spectralmatch.handlers.write_vector","title":"<code>write_vector(mem_ds, output_vector_path)</code>","text":"<p>Writes an in-memory OGR DataSource to disk in a supported vector format.</p> <p>Parameters:</p> Name Type Description Default <code>mem_ds</code> <code>DataSource</code> <p>In-memory vector data source.</p> required <code>output_vector_path</code> <code>str</code> <p>Output file path (.shp, .geojson, or .gpkg).</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no suitable driver is found or output creation fails.</p> Source code in <code>spectralmatch/handlers.py</code> <pre><code>def write_vector(\n    mem_ds: ogr.DataSource,\n    output_vector_path: str\n    ) -&gt; None:\n    \"\"\"\n    Writes an in-memory OGR DataSource to disk in a supported vector format.\n\n    Args:\n        mem_ds (ogr.DataSource): In-memory vector data source.\n        output_vector_path (str): Output file path (.shp, .geojson, or .gpkg).\n\n    Returns:\n        None\n\n    Raises:\n        RuntimeError: If no suitable driver is found or output creation fails.\n    \"\"\"\n\n    driver_mapping = {\n        '.shp': 'ESRI Shapefile',\n        '.geojson': 'GeoJSON',\n        '.gpkg': 'GPKG'\n    }\n    ext = os.path.splitext(output_vector_path)[1].lower()\n    driver_name = driver_mapping.get(ext, 'GeoJSON')  # Fallback to GeoJSON if unknown.\n\n    driver = ogr.GetDriverByName(driver_name)\n    if driver is None:\n        raise RuntimeError(f\"No driver found for extension: {ext}\")\n\n    # If the output file already exists, delete it.\n    if os.path.exists(output_vector_path):\n        driver.DeleteDataSource(output_vector_path)\n\n    out_ds = driver.CreateDataSource(output_vector_path)\n    if out_ds is None:\n        raise RuntimeError(f\"Could not create output vector dataset: {output_vector_path}\")\n\n    # Loop over every layer in the in-memory datasource and copy it.\n    for i in range(mem_ds.GetLayerCount()):\n        mem_layer = mem_ds.GetLayerByIndex(i)\n        layer_name = mem_layer.GetName()\n        srs = mem_layer.GetSpatialRef()\n        geom_type = mem_layer.GetGeomType()\n\n        out_layer = out_ds.CreateLayer(layer_name, srs, geom_type)\n\n        # Copy field definitions\n        mem_defn = mem_layer.GetLayerDefn()\n        for j in range(mem_defn.GetFieldCount()):\n            field_defn = mem_defn.GetFieldDefn(j)\n            out_layer.CreateField(field_defn)\n\n        # Copy features (including geometry, fields, and feature-level metadata)\n        mem_layer.ResetReading()\n        for feat in mem_layer:\n            out_feat = ogr.Feature(out_layer.GetLayerDefn())\n            out_feat.SetGeometry(feat.GetGeometryRef().Clone())\n            for j in range(mem_defn.GetFieldCount()):\n                field_name = mem_defn.GetFieldDefn(j).GetNameRef()\n                out_feat.SetField(field_name, feat.GetField(j))\n            out_layer.CreateFeature(out_feat)\n            out_feat = None\n    out_ds.Destroy()\n</code></pre>"},{"location":"api/mask/","title":"Create Mask and Pseudo-Invariant Features","text":""},{"location":"api/mask/#spectralmatch.mask.create_cloud_mask_with_omnicloudmask","title":"<code>create_cloud_mask_with_omnicloudmask(input_image_path, red_band_index, green_band_index, nir_band_index, output_mask_path, down_sample_m=None)</code>","text":"<p>Generates a cloud mask using OmniCloudMask from a multi-band image.</p> <p>Parameters:</p> Name Type Description Default <code>input_image_path</code> <code>str</code> <p>Path to the input image.</p> required <code>red_band_index</code> <code>int</code> <p>Index of the red band.</p> required <code>green_band_index</code> <code>int</code> <p>Index of the green band.</p> required <code>nir_band_index</code> <code>int</code> <p>Index of the NIR (or substitute blue) band.</p> required <code>output_mask_path</code> <code>str</code> <p>Path to save the output cloud mask GeoTIFF.</p> required <code>down_sample_m</code> <code>float</code> <p>Target resolution (in meters) to downsample the input before processing.</p> <code>None</code> Outputs <p>Saves a single-band cloud mask GeoTIFF at the specified path.</p> Source code in <code>spectralmatch/mask.py</code> <pre><code>def create_cloud_mask_with_omnicloudmask(\n    input_image_path,\n    red_band_index,\n    green_band_index,\n    nir_band_index, # Blue band can work if nir isnt available\n    output_mask_path,\n    down_sample_m=None, # Down sample to 10 m if imagery has a spatial resolution &lt; 10 m\n    ):\n    \"\"\"\n    Generates a cloud mask using OmniCloudMask from a multi-band image.\n\n    Args:\n        input_image_path (str): Path to the input image.\n        red_band_index (int): Index of the red band.\n        green_band_index (int): Index of the green band.\n        nir_band_index (int): Index of the NIR (or substitute blue) band.\n        output_mask_path (str): Path to save the output cloud mask GeoTIFF.\n        down_sample_m (float, optional): Target resolution (in meters) to downsample the input before processing.\n\n    Outputs:\n        Saves a single-band cloud mask GeoTIFF at the specified path.\n    \"\"\"\n\n    with rasterio.open(input_image_path) as src:\n        if down_sample_m is not None:\n            # Compute new dimensions based on the image bounds and the desired resolution.\n            left, bottom, right, top = src.bounds\n            new_width = int((right - left) / down_sample_m)\n            new_height = int((top - bottom) / down_sample_m)\n            new_transform = from_origin(left, top, down_sample_m, down_sample_m)\n            # Read the bands with resampling to the new size.\n            red   = src.read(red_band_index, out_shape=(new_height, new_width),\n                             resampling=Resampling.bilinear)\n            green = src.read(green_band_index, out_shape=(new_height, new_width),\n                             resampling=Resampling.bilinear)\n            nir   = src.read(nir_band_index, out_shape=(new_height, new_width),\n                             resampling=Resampling.bilinear)\n            meta = src.meta.copy()\n            meta.update({\n                'width': new_width,\n                'height': new_height,\n                'transform': new_transform,\n            })\n        else:\n            # Read without resampling.\n            red   = src.read(red_band_index)\n            green = src.read(green_band_index)\n            nir   = src.read(nir_band_index)\n            meta = src.meta.copy()\n\n        # Stack bands into an array of shape (3, height, width).\n        band_array = np.stack([red, green, nir], axis=0)\n\n    # Predict the mask (expected shape: (1, height, width))\n    pred_mask = predict_from_array(band_array)\n    pred_mask = np.squeeze(pred_mask)\n\n    # Update metadata for a single-band output.\n    meta.update({\n        'driver': 'GTiff',\n        'count': 1,\n        'dtype': pred_mask.dtype,\n        'nodata': 0,\n    })\n\n    # Write the predicted mask to a GeoTIFF file.\n    with rasterio.open(output_mask_path, 'w', **meta) as dst:\n        dst.write(pred_mask, 1)\n</code></pre>"},{"location":"api/mask/#spectralmatch.mask.create_ndvi_mask","title":"<code>create_ndvi_mask(input_image_path, output_image_path, nir_band=4, red_band=3)</code>","text":"<p>Computes NDVI from a multi-band image and saves the result as a VRT raster.</p> <p>Parameters:</p> Name Type Description Default <code>input_image_path</code> <code>str</code> <p>Path to the input image with NIR and red bands.</p> required <code>output_image_path</code> <code>str</code> <p>Path to save the NDVI output as a VRT file.</p> required <code>nir_band</code> <code>int</code> <p>Band index for NIR. Defaults to 4.</p> <code>4</code> <code>red_band</code> <code>int</code> <p>Band index for red. Defaults to 3.</p> <code>3</code> <p>Returns:</p> Name Type Description <code>str</code> <p>Path to the saved NDVI output.</p> Source code in <code>spectralmatch/mask.py</code> <pre><code>def create_ndvi_mask(\n    input_image_path: str,\n    output_image_path: str,\n    nir_band: int=4,\n    red_band: int=3,\n    ):\n    \"\"\"\n    Computes NDVI from a multi-band image and saves the result as a VRT raster.\n\n    Args:\n        input_image_path (str): Path to the input image with NIR and red bands.\n        output_image_path (str): Path to save the NDVI output as a VRT file.\n        nir_band (int, optional): Band index for NIR. Defaults to 4.\n        red_band (int, optional): Band index for red. Defaults to 3.\n\n    Returns:\n        str: Path to the saved NDVI output.\n    \"\"\"\n\n    ds = gdal.Open(input_image_path)\n    nir = ds.GetRasterBand(nir_band).ReadAsArray().astype(np.float32)\n    red = ds.GetRasterBand(red_band).ReadAsArray().astype(np.float32)\n    ndvi = (nir - red) / (nir + red + 1e-9)  # avoid division by zero\n\n    mem_drv = gdal.GetDriverByName(\"MEM\")\n    mem_ds = mem_drv.Create(\"\", ds.RasterXSize, ds.RasterYSize, 1, gdal.GDT_Float32)\n    mem_ds.SetGeoTransform(ds.GetGeoTransform())\n    mem_ds.SetProjection(ds.GetProjection())\n    mem_ds.GetRasterBand(1).WriteArray(ndvi)\n\n    gdal.GetDriverByName(\"VRT\").CreateCopy(output_image_path, mem_ds)\n    ds, mem_ds = None, None\n    return output_image_path\n</code></pre>"},{"location":"api/mask/#spectralmatch.mask.post_process_raster_cloud_mask_to_vector","title":"<code>post_process_raster_cloud_mask_to_vector(input_image_path, minimum_mask_size_percentile=None, polygon_buffering_in_map_units=None, value_mapping=None)</code>","text":"<p>Converts a raster cloud mask to a vector layer with optional filtering, buffering, and merging.</p> <p>Parameters:</p> Name Type Description Default <code>input_image_path</code> <code>str</code> <p>Path to the input cloud mask raster.</p> required <code>minimum_mask_size_percentile</code> <code>float</code> <p>Percentile threshold to filter small polygons by area.</p> <code>None</code> <code>polygon_buffering_in_map_units</code> <code>dict</code> <p>Mapping of raster values to buffer distances.</p> <code>None</code> <code>value_mapping</code> <code>dict</code> <p>Mapping of original raster values to new values before vectorization.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataSource</code> <p>ogr.DataSource: In-memory vector layer with merged and filtered polygons.</p> Outputs <p>Returns an OGR DataSource containing post-processed vector features.</p> Source code in <code>spectralmatch/mask.py</code> <pre><code>def post_process_raster_cloud_mask_to_vector(\n    input_image_path: str,\n    minimum_mask_size_percentile: float = None,\n    polygon_buffering_in_map_units: dict = None,\n    value_mapping: dict = None\n    ) -&gt; ogr.DataSource:\n    \"\"\"\n    Converts a raster cloud mask to a vector layer with optional filtering, buffering, and merging.\n\n    Args:\n        input_image_path (str): Path to the input cloud mask raster.\n        minimum_mask_size_percentile (float, optional): Percentile threshold to filter small polygons by area.\n        polygon_buffering_in_map_units (dict, optional): Mapping of raster values to buffer distances.\n        value_mapping (dict, optional): Mapping of original raster values to new values before vectorization.\n\n    Returns:\n        ogr.DataSource: In-memory vector layer with merged and filtered polygons.\n\n    Outputs:\n        Returns an OGR DataSource containing post-processed vector features.\n    \"\"\"\n\n    with rasterio.open(input_image_path) as src:\n        raster_data = src.read(1)\n        transform = src.transform\n        crs = src.crs\n\n    if value_mapping is not None:\n        mapped = np.copy(raster_data)\n        for orig_value, new_value in value_mapping.items():\n            mapped[raster_data == orig_value] = new_value\n        raster_data = mapped\n\n    results = (\n        {'properties': {'value': v}, 'geometry': s}\n        for s, v in shapes(raster_data, transform=transform, connectivity=4)\n    )\n    features = list(results)\n    if not features:\n        print(\"No features were detected in the raster mask.\")\n        return None\n\n\n    gdf = gpd.GeoDataFrame.from_features(features, crs=crs)\n\n    gdf['area'] = gdf.geometry.area\n    if minimum_mask_size_percentile is not None:\n        area_threshold = np.percentile(gdf['area'], minimum_mask_size_percentile)\n        print(f\"Area threshold (at {minimum_mask_size_percentile}th percentile): {area_threshold:.2f}\")\n        gdf = gdf[gdf['area'] &gt;= area_threshold].copy()\n\n    if polygon_buffering_in_map_units is not None:\n        gdf['geometry'] = gdf.apply(\n            lambda row: row['geometry'].buffer(polygon_buffering_in_map_units.get(row['value'], 0))\n            if row['value'] in polygon_buffering_in_map_units else row['geometry'],\n            axis=1\n        )\n\n    merged_features = []\n    for val, group in gdf.groupby('value'):\n        # Use union_all() to merge the geometries within the group.\n        # (Requires Shapely 2.0 or later; otherwise use shapely.ops.unary_union on group.geometry.tolist())\n        union_geom = group.geometry.union_all()\n        # If the union produces a single Polygon, add it directly;\n        # if it produces a MultiPolygon, split it into individual features.\n        if union_geom.geom_type == 'Polygon':\n            merged_features.append({'value': val, 'geometry': union_geom})\n        elif union_geom.geom_type == 'MultiPolygon':\n            for geom in union_geom.geoms:\n                merged_features.append({'value': val, 'geometry': geom})\n        else:\n            # In case of unexpected geometry types, skip or handle accordingly.\n            print(f\"Unexpected geometry type for value {val}: {union_geom.geom_type}\")\n    # Create a new GeoDataFrame from merged features.\n    gdf = gpd.GeoDataFrame(merged_features, crs=gdf.crs)\n\n\n    ogr_driver = ogr.GetDriverByName(\"Memory\")\n    mem_ds = ogr_driver.CreateDataSource(\"in_memory\")\n\n    # Determine an appropriate OGR geometry type using the first feature.\n    first_geom = gdf.geometry.iloc[0]\n    if first_geom.geom_type == \"Polygon\":\n        ogr_geom_type = ogr.wkbPolygon\n    elif first_geom.geom_type == \"MultiPolygon\":\n        ogr_geom_type = ogr.wkbMultiPolygon\n    else:\n        ogr_geom_type = ogr.wkbUnknown\n\n    # Convert the CRS to OGR SpatialReference.\n    sr = osr.SpatialReference()\n    try:\n        sr.ImportFromWkt(crs.to_wkt())\n    except AttributeError:\n        sr.ImportFromEPSG(4326)\n\n    mem_layer = mem_ds.CreateLayer(\"post_processed\", sr, ogr_geom_type)\n\n    # Add attribute field for 'value' (and any other non-geometry columns if needed).\n    # Here we add 'value' for example.\n    field_defn = ogr.FieldDefn(\"value\", ogr.OFTInteger)\n    mem_layer.CreateField(field_defn)\n\n    # Add each row from the GeoDataFrame as an OGR feature.\n    for idx, row in gdf.iterrows():\n        feat = ogr.Feature(mem_layer.GetLayerDefn())\n        ogr_geom = ogr.CreateGeometryFromWkt(row['geometry'].wkt)\n        feat.SetGeometry(ogr_geom)\n        feat.SetField(\"value\", row['value'])\n        mem_layer.CreateFeature(feat)\n        feat = None\n\n    return mem_ds\n</code></pre>"},{"location":"api/mask/#spectralmatch.mask.post_process_threshold_to_vector","title":"<code>post_process_threshold_to_vector(input_image_path, output_vector_path, threshold_val, operator_str='&lt;=')</code>","text":"<p>Converts a thresholded raster mask to a vector layer based on a comparison operator.</p> <p>Parameters:</p> Name Type Description Default <code>input_image_path</code> <code>str</code> <p>Path to the input single-band raster.</p> required <code>output_vector_path</code> <code>str</code> <p>Path to save the output vector file (GeoPackage).</p> required <code>threshold_val</code> <code>float | int</code> <p>Threshold value to apply.</p> required <code>operator_str</code> <code>str</code> <p>Comparison operator ('&lt;=', '&gt;=', '&lt;', '&gt;', '=='). Defaults to '&lt;='.</p> <code>'&lt;='</code> <p>Returns:</p> Name Type Description <code>str</code> <p>Path to the saved vector file.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unsupported comparison operator is provided.</p> Source code in <code>spectralmatch/mask.py</code> <pre><code>def post_process_threshold_to_vector(\n    input_image_path: str,\n    output_vector_path: str,\n    threshold_val: float | int,\n    operator_str: str=\"&lt;=\",\n    ):\n    \"\"\"\n    Converts a thresholded raster mask to a vector layer based on a comparison operator.\n\n    Args:\n        input_image_path (str): Path to the input single-band raster.\n        output_vector_path (str): Path to save the output vector file (GeoPackage).\n        threshold_val (float | int): Threshold value to apply.\n        operator_str (str, optional): Comparison operator ('&lt;=', '&gt;=', '&lt;', '&gt;', '=='). Defaults to '&lt;='.\n\n    Returns:\n        str: Path to the saved vector file.\n\n    Raises:\n        ValueError: If an unsupported comparison operator is provided.\n    \"\"\"\n\n    ds = gdal.Open(input_image_path)\n    band = ds.GetRasterBand(1)\n    arr = band.ReadAsArray()\n\n    if operator_str == \"&lt;=\":\n        mask = arr &lt;= threshold_val\n    elif operator_str == \"&gt;=\":\n        mask = arr &gt;= threshold_val\n    elif operator_str == \"&lt;\":\n        mask = arr &lt; threshold_val\n    elif operator_str == \"&gt;\":\n        mask = arr &gt; threshold_val\n    elif operator_str == \"==\":\n        mask = arr == threshold_val\n    else:\n        raise ValueError(\"Unsupported operator\")\n\n    mask = mask.astype(np.uint8)\n\n    mem_ds = gdal.GetDriverByName(\"MEM\").Create(\"\", ds.RasterXSize, ds.RasterYSize, 1, gdal.GDT_Byte)\n    mem_ds.SetGeoTransform(ds.GetGeoTransform())\n    mem_ds.SetProjection(ds.GetProjection())\n    mem_ds.GetRasterBand(1).WriteArray(mask)\n\n    drv = ogr.GetDriverByName(\"GPKG\")\n    if os.path.exists(output_vector_path):\n        drv.DeleteDataSource(output_vector_path)\n    out_ds = drv.CreateDataSource(output_vector_path)\n    out_lyr = out_ds.CreateLayer(\"mask\", srs=None)\n    out_lyr.CreateField(ogr.FieldDefn(\"DN\", ogr.OFTInteger))\n\n    gdal.Polygonize(mem_ds.GetRasterBand(1), mem_ds.GetRasterBand(1), out_lyr, 0, [])\n    ds, mem_ds, out_ds = None, None, None\n    return output_vector_path\n</code></pre>"},{"location":"api/match/","title":"Matching Algorithms","text":""},{"location":"api/match/#spectralmatch.match.global_regression.global_regression","title":"<code>global_regression(input_image_paths, output_image_folder, *, custom_mean_factor=1.0, custom_std_factor=1.0, output_global_basename='_global', vector_mask_path=None, tile_width_and_height_tuple=None, debug_mode=False, custom_nodata_value=None, parallel=False, max_workers=None, calc_dtype='float32')</code>","text":"<p>Performs global radiometric normalization across overlapping images using least squares regression.</p> <p>Parameters:</p> Name Type Description Default <code>input_image_paths</code> <code>List[str]</code> <p>List of input raster image paths.</p> required <code>output_image_folder</code> <code>str</code> <p>Folder to save normalized output images.</p> required <code>custom_mean_factor</code> <code>float</code> <p>Weight for mean constraints in regression. Defaults to 1.0.</p> <code>1.0</code> <code>custom_std_factor</code> <code>float</code> <p>Weight for standard deviation constraints in regression. Defaults to 1.0.</p> <code>1.0</code> <code>output_global_basename</code> <code>str</code> <p>Suffix for output filenames. Defaults to \"_global\".</p> <code>'_global'</code> <code>vector_mask_path</code> <code>Optional[str]</code> <p>Optional mask to limit stats to specific areas. Defaults to None.</p> <code>None</code> <code>tile_width_and_height_tuple</code> <code>Optional[Tuple[int, int]]</code> <p>Tile size for block-wise processing. Defaults to None.</p> <code>None</code> <code>debug_mode</code> <code>bool</code> <p>If True, prints debug information and constraint matrices. Defaults to False.</p> <code>False</code> <code>custom_nodata_value</code> <code>float | None</code> <p>Overrides detected NoData value. Defaults to None.</p> <code>None</code> <code>parallel</code> <code>bool</code> <p>Enables parallel tile processing. Defaults to False.</p> <code>False</code> <code>max_workers</code> <code>int | None</code> <p>Number of worker processes. Defaults to CPU count.</p> <code>None</code> <code>calc_dtype</code> <code>str</code> <p>Data type used for internal calculations. Defaults to \"float32\".</p> <code>'float32'</code> <p>Returns:</p> Type Description <p>List[str]: Paths to the globally adjusted output raster images.</p> Source code in <code>spectralmatch/match/global_regression.py</code> <pre><code>def global_regression(\n    input_image_paths: List[str],\n    output_image_folder: str,\n    *,\n    custom_mean_factor: float = 1.0,\n    custom_std_factor: float = 1.0,\n    output_global_basename: str = \"_global\",\n    vector_mask_path: Optional[str] = None,\n    tile_width_and_height_tuple: Optional[Tuple[int, int]] = None,\n    debug_mode: bool = False,\n    custom_nodata_value: float | None = None,\n    parallel: bool = False,\n    max_workers: int | None = None,\n    calc_dtype: str = \"float32\",\n    ):\n    \"\"\"\n    Performs global radiometric normalization across overlapping images using least squares regression.\n\n    Args:\n        input_image_paths (List[str]): List of input raster image paths.\n        output_image_folder (str): Folder to save normalized output images.\n        custom_mean_factor (float, optional): Weight for mean constraints in regression. Defaults to 1.0.\n        custom_std_factor (float, optional): Weight for standard deviation constraints in regression. Defaults to 1.0.\n        output_global_basename (str, optional): Suffix for output filenames. Defaults to \"_global\".\n        vector_mask_path (Optional[str], optional): Optional mask to limit stats to specific areas. Defaults to None.\n        tile_width_and_height_tuple (Optional[Tuple[int, int]], optional): Tile size for block-wise processing. Defaults to None.\n        debug_mode (bool, optional): If True, prints debug information and constraint matrices. Defaults to False.\n        custom_nodata_value (float | None, optional): Overrides detected NoData value. Defaults to None.\n        parallel (bool, optional): Enables parallel tile processing. Defaults to False.\n        max_workers (int | None, optional): Number of worker processes. Defaults to CPU count.\n        calc_dtype (str, optional): Data type used for internal calculations. Defaults to \"float32\".\n\n    Returns:\n        List[str]: Paths to the globally adjusted output raster images.\n    \"\"\"\n\n    print(\"Start global matching\")\n\n    _check_raster_requirements(input_image_paths, debug_mode)\n\n    nodata_val = _get_nodata_value(input_image_paths, custom_nodata_value)\n\n    if debug_mode: print(\"Calculating statistics\")\n    with rasterio.open(input_image_paths[0]) as src: num_bands = src.count\n    num_images = len(input_image_paths)\n\n    all_bounds = {}\n    for idx, p in enumerate(input_image_paths):\n        with rasterio.open(p) as ds:\n            all_bounds[idx] = ds.bounds\n\n    overlapping_pairs = _find_overlaps(all_bounds)\n\n    all_overlap_stats = {}\n    for id_i, id_j in overlapping_pairs:\n        stats = _calculate_overlap_stats(\n            num_bands,\n            input_image_paths[id_i],\n            input_image_paths[id_j],\n            id_i,\n            id_j,\n            all_bounds[id_i],\n            all_bounds[id_j],\n            nodata_val,\n            nodata_val,\n            vector_mask_path=vector_mask_path,\n            tile_width_and_height_tuple=tile_width_and_height_tuple,\n            debug_mode=debug_mode,\n        )\n        all_overlap_stats.update(\n            {\n                k_i: {\n                    **all_overlap_stats.get(k_i, {}),\n                    **{\n                        k_j: {**all_overlap_stats.get(k_i, {}).get(k_j, {}), **s}\n                        for k_j, s in v.items()\n                    },\n                }\n                for k_i, v in stats.items()\n            }\n        )\n\n    all_whole_stats = {}\n    for idx, path in enumerate(input_image_paths):\n        all_whole_stats.update(\n            _calculate_whole_stats(\n                input_image_path=path,\n                nodata=nodata_val,\n                num_bands=num_bands,\n                image_id=idx,\n                vector_mask_path=vector_mask_path,\n                tile_width_and_height_tuple=tile_width_and_height_tuple,\n            )\n        )\n\n    all_params = np.zeros((num_bands, 2 * num_images, 1), dtype=float)\n    for b in range(num_bands):\n        if debug_mode: print(f\"Processing band {b} for {num_images} images\")\n\n        A, y, tot_overlap = [], [], 0\n        for i in range(num_images):\n\n            for j in range(i + 1, num_images):\n                stat = all_overlap_stats.get(i, {}).get(j)\n                if stat is None:\n                    continue\n                s = stat[b][\"size\"]\n                m1, v1 = stat[b][\"mean\"], stat[b][\"std\"]\n                m2, v2 = (\n                    all_overlap_stats[j][i][b][\"mean\"],\n                    all_overlap_stats[j][i][b][\"std\"],\n                )\n                row_m = [0] * (2 * num_images)\n                row_s = [0] * (2 * num_images)\n                row_m[2 * i : 2 * i + 2] = [m1, 1]\n                row_m[2 * j : 2 * j + 2] = [-m2, -1]\n                row_s[2 * i], row_s[2 * j] = v1, -v2\n                A.extend(\n                    [\n                        [v * s * custom_mean_factor for v in row_m],\n                        [v * s * custom_std_factor for v in row_s],\n                    ]\n                )\n                y.extend([0, 0])\n                tot_overlap += s\n        pjj = 1.0 if tot_overlap == 0 else tot_overlap / (2.0 * num_images)\n        for j in range(num_images):\n            mj = all_whole_stats[j][b][\"mean\"]\n            vj = all_whole_stats[j][b][\"std\"]\n            row_m = [0] * (2 * num_images)\n            row_s = [0] * (2 * num_images)\n            row_m[2 * j : 2 * j + 2] = [mj * pjj, 1 * pjj]\n            row_s[2 * j] = vj * pjj\n            A.extend([row_m, row_s])\n            y.extend([mj * pjj, vj * pjj])\n\n        A_arr = np.asarray(A)\n        y_arr = np.asarray(y)\n        res = least_squares(lambda p: np.asarray(A) @ p - np.asarray(y), [1, 0] * num_images)\n        if debug_mode:\n            overlap_pairs = overlapping_pairs\n            _print_constraint_system(\n                constraint_matrix=A_arr,\n                adjustment_params=res.x,\n                observed_values_vector=y_arr,\n                overlap_pairs=overlap_pairs,\n                num_images=num_images,\n            )\n\n        all_params[b] = res.x.reshape((2 * num_images, 1))\n\n    img_dir = os.path.join(output_image_folder, \"Images\")\n    if not os.path.exists(img_dir): os.makedirs(img_dir)\n    out_paths: List[str] = []\n\n    if parallel and max_workers is None:\n        max_workers = mp.cpu_count()\n\n    for img_idx, img_path in enumerate(input_image_paths):\n        base = os.path.splitext(os.path.basename(img_path))[0]\n        out_path = os.path.join(img_dir, f\"{base}{output_global_basename}.tif\")\n        out_paths.append(str(out_path))\n\n        if debug_mode: print(f\"Apply adjustments and saving results for {base}\")\n        with rasterio.open(img_path) as src:\n            meta = src.meta.copy()\n            meta.update({\"count\": num_bands, \"nodata\": nodata_val})\n            with rasterio.open(out_path, \"w\", **meta) as dst:\n\n                if tile_width_and_height_tuple:\n                    tw, th = tile_width_and_height_tuple\n                    windows = list(_create_windows(src.width, src.height, tw, th))\n                else:\n                    windows = [Window(0, 0, src.width, src.height)]\n\n                if parallel:\n                    ctx = _choose_context(prefer_fork=True)\n                    pool = ProcessPoolExecutor(\n                        max_workers=max_workers,\n                        mp_context=ctx,\n                        initializer=_init_worker,\n                        initargs=(img_path,),\n                    )\n\n                for b in range(num_bands):\n                    a = all_params[b, 2 * img_idx, 0]\n                    b0 = all_params[b, 2 * img_idx + 1, 0]\n\n                    if parallel:\n                        futs = [\n                            pool.submit(_process_tile_global,\n                                        w,\n                                        b,\n                                        a,\n                                        b0,\n                                        nodata_val,\n                                        calc_dtype,\n                                        debug_mode,\n                                        )\n                            for w in windows\n                        ]\n                        for fut in as_completed(futs):\n                            win, buf = fut.result()\n                            dst.write(buf.astype(meta[\"dtype\"]), b + 1, window=win)\n                    else:\n                        for win in windows:\n                            _, buf = _process_tile_global(\n                                win,\n                                b,\n                                a,\n                                b0,\n                                nodata_val,\n                                debug_mode,\n                            )\n                            dst.write(buf.astype(meta[\"dtype\"]), b + 1, window=win)\n                if parallel:\n                    pool.shutdown()\n\n    print(\"Finished global matching\")\n    return out_paths\n</code></pre>"},{"location":"api/match/#spectralmatch.match.local_block_adjustment.local_block_adjustment","title":"<code>local_block_adjustment(input_image_paths, output_image_folder, *, output_local_basename='_local', custom_nodata_value=None, target_blocks_per_image=100, alpha=1.0, calculation_dtype_precision='float32', output_dtype='float32', projection='EPSG:4326', debug_mode=False, tile_width_and_height_tuple=None, correction_method='gamma', parallel=False, max_workers=None)</code>","text":"<p>Performs local radiometric adjustment on a set of raster images using block-based statistics.</p> <p>Parameters:</p> Name Type Description Default <code>input_image_paths</code> <code>List[str]</code> <p>List of raster image paths to adjust.</p> required <code>output_image_folder</code> <code>str</code> <p>Folder to save corrected output rasters.</p> required <code>output_local_basename</code> <code>str</code> <p>Suffix for output filenames. Defaults to \"_local\".</p> <code>'_local'</code> <code>custom_nodata_value</code> <code>float | None</code> <p>Overrides detected NoData value. Defaults to None.</p> <code>None</code> <code>target_blocks_per_image</code> <code>int</code> <p>Approximate number of blocks per image. Defaults to 100.</p> <code>100</code> <code>alpha</code> <code>float</code> <p>Blending factor between global and local means. Defaults to 1.0.</p> <code>1.0</code> <code>calculation_dtype_precision</code> <code>str</code> <p>Precision for internal calculations. Defaults to \"float32\".</p> <code>'float32'</code> <code>output_dtype</code> <code>str</code> <p>Data type for output rasters. Defaults to \"float32\".</p> <code>'float32'</code> <code>projection</code> <code>str</code> <p>CRS projection string for output block maps. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>debug_mode</code> <code>bool</code> <p>If True, saves intermediate block maps and prints progress. Defaults to False.</p> <code>False</code> <code>tile_width_and_height_tuple</code> <code>Tuple[int, int]</code> <p>Tile size for block-wise correction. Defaults to None.</p> <code>None</code> <code>correction_method</code> <code>Literal['gamma', 'linear']</code> <p>Local correction method. Defaults to \"gamma\".</p> <code>'gamma'</code> <code>parallel</code> <code>bool</code> <p>If True, enables multiprocessing. Defaults to False.</p> <code>False</code> <code>max_workers</code> <code>int | None</code> <p>Max number of parallel workers. Defaults to number of CPUs.</p> <code>None</code> <p>Returns:</p> Type Description <p>List[str]: Paths to the locally adjusted output raster images.</p> Source code in <code>spectralmatch/match/local_block_adjustment.py</code> <pre><code>def local_block_adjustment(\n    input_image_paths: List[str],\n    output_image_folder: str,\n    *,\n    output_local_basename: str = \"_local\",\n    custom_nodata_value: float | None = None,\n    target_blocks_per_image: int = 100,\n    alpha: float = 1.0,\n    calculation_dtype_precision: str = \"float32\",\n    output_dtype: str = \"float32\",\n    projection: str = \"EPSG:4326\",\n    debug_mode: bool = False,\n    tile_width_and_height_tuple: Optional[Tuple[int, int]] = None,\n    correction_method: Literal[\"gamma\", \"linear\"] = \"gamma\",\n    parallel: bool = False,\n    max_workers: int | None = None,\n    ):\n    \"\"\"\n    Performs local radiometric adjustment on a set of raster images using block-based statistics.\n\n    Args:\n        input_image_paths (List[str]): List of raster image paths to adjust.\n        output_image_folder (str): Folder to save corrected output rasters.\n        output_local_basename (str, optional): Suffix for output filenames. Defaults to \"_local\".\n        custom_nodata_value (float | None, optional): Overrides detected NoData value. Defaults to None.\n        target_blocks_per_image (int, optional): Approximate number of blocks per image. Defaults to 100.\n        alpha (float, optional): Blending factor between global and local means. Defaults to 1.0.\n        calculation_dtype_precision (str, optional): Precision for internal calculations. Defaults to \"float32\".\n        output_dtype (str, optional): Data type for output rasters. Defaults to \"float32\".\n        projection (str, optional): CRS projection string for output block maps. Defaults to \"EPSG:4326\".\n        debug_mode (bool, optional): If True, saves intermediate block maps and prints progress. Defaults to False.\n        tile_width_and_height_tuple (Tuple[int, int], optional): Tile size for block-wise correction. Defaults to None.\n        correction_method (Literal[\"gamma\", \"linear\"], optional): Local correction method. Defaults to \"gamma\".\n        parallel (bool, optional): If True, enables multiprocessing. Defaults to False.\n        max_workers (int | None, optional): Max number of parallel workers. Defaults to number of CPUs.\n\n    Returns:\n        List[str]: Paths to the locally adjusted output raster images.\n    \"\"\"\n\n    print(\"Start local matching\")\n    _check_raster_requirements(input_image_paths, debug_mode)\n\n    nodata_val = _get_nodata_value(input_image_paths, custom_nodata_value)\n    if debug_mode: print(f\"Global nodata value: {nodata_val}\")\n\n    out_img_dir = os.path.join(output_image_folder, \"Images\")\n    if not os.path.exists(out_img_dir): os.makedirs(out_img_dir)\n\n    bounding_rect = _get_bounding_rectangle(input_image_paths)\n    M, N = _compute_block_size(input_image_paths, target_blocks_per_image, bounding_rect)\n    # M, N = _compute_mosaic_coefficient_of_variation(input_image_paths, global_nodata_value) # Aproach from the paper to compute bock size\n\n    with rasterio.open(input_image_paths[0]) as ds:\n        num_bands = ds.count\n\n    if debug_mode: print(\"Computing global reference block map\")\n    block_ref_mean, _ = _compute_blocks(\n        input_image_paths,\n        bounding_rect,\n        M,\n        N,\n        num_bands,\n        nodata_value=nodata_val,\n        tile_width_and_height_tuple=tile_width_and_height_tuple,\n    )\n\n    if debug_mode:\n        _download_block_map(\n            block_map=np.nan_to_num(block_ref_mean, nan=nodata_val),\n            bounding_rect=bounding_rect,\n            output_image_path= os.path.join(output_image_folder, \"BlockReferenceMean\", \"BlockReferenceMean.tif\"),\n            nodata_value=nodata_val,\n            projection=projection,\n        )\n\n    if parallel and max_workers is None:\n        max_workers = mp.cpu_count()\n\n    out_paths: List[str] = []\n    for img_path in input_image_paths:\n        in_name = os.path.splitext(os.path.basename(img_path))[0]\n        out_name = os.path.splitext(os.path.basename(img_path))[0] + output_local_basename\n        out_path = os.path.join(out_img_dir, f\"{out_name}.tif\")\n        out_paths.append(str(out_path))\n\n        if debug_mode: print(f\"Processing {in_name}\")\n        if debug_mode: print(f\"Computing local block map\")\n        block_loc_mean, block_loc_count = _compute_blocks(\n            [img_path],\n            bounding_rect,\n            M,\n            N,\n            num_bands,\n            nodata_value=nodata_val,\n            tile_width_and_height_tuple=tile_width_and_height_tuple,\n        )\n\n        # block_local_mean = _smooth_array(block_local_mean, nodata_value=global_nodata_value)\n\n        if debug_mode:\n            _download_block_map(\n                block_map=np.nan_to_num(block_loc_mean, nan=nodata_val),\n                bounding_rect=bounding_rect,\n                output_image_path=os.path.join(output_image_folder, \"BlockLocalMean\", f\"{out_name}_BlockLocalMean.tif\"),\n                nodata_value=nodata_val,\n                projection=projection,\n            )\n            _download_block_map(\n                block_map=np.nan_to_num(block_loc_count, nan=nodata_val),\n                bounding_rect=bounding_rect,\n                output_image_path=os.path.join(output_image_folder, \"BlockLocalCount\", f\"{out_name}_BlockLocalCount.tif\"),\n                nodata_value=nodata_val,\n                projection=projection,\n            )\n\n        if debug_mode: print(f\"Computing local correction, applying, and saving\")\n        with rasterio.open(img_path) as src:\n            meta = src.meta.copy()\n            meta.update({\"count\": num_bands, \"dtype\": output_dtype, \"nodata\": nodata_val})\n            with rasterio.open(out_path, \"w\", **meta) as dst:\n\n                if tile_width_and_height_tuple:\n                    tw, th = tile_width_and_height_tuple\n                    windows = list(_create_windows(src.width, src.height, tw, th))\n                else:\n                    windows = [Window(0, 0, src.width, src.height)]\n\n                if parallel:\n                    ctx = _choose_context(prefer_fork=True)\n\n                    pool = ProcessPoolExecutor(\n                        max_workers=max_workers,\n                        mp_context=ctx,\n                        initializer=_init_worker,\n                        initargs=(img_path,),\n                    )\n\n                    futures = [\n                        pool.submit(_compute_tile_local,\n                                    w,\n                                    b,\n                                    M,\n                                    N,\n                                    bounding_rect,\n                                    block_ref_mean,\n                                    block_loc_mean,\n                                    nodata_val,\n                                    alpha,\n                                    correction_method,\n                                    calculation_dtype_precision,\n                                    debug_mode,\n                                    )\n                        for b in range(num_bands)\n                        for w in windows\n                    ]\n                    for fut in as_completed(futures):\n                        win, b_idx, buf = fut.result()\n                        dst.write(buf.astype(output_dtype), b_idx + 1, window=win)\n                    pool.shutdown()\n                else:\n                    _init_worker(img_path)\n\n                    for b in range(num_bands):\n                        for win in windows:\n                            win_, b_idx, buf = _compute_tile_local(\n                                win,\n                                b,\n                                M,\n                                N,\n                                bounding_rect,\n                                block_ref_mean,\n                                block_loc_mean,\n                                nodata_val,\n                                alpha,\n                                correction_method,\n                                calculation_dtype_precision,\n                                debug_mode\n                            )\n                            dst.write(buf.astype(output_dtype), b_idx + 1, window=win_)\n    print(\"Finished local matching\")\n    return out_paths\n</code></pre>"},{"location":"api/statistics/","title":"Creating Statistical Figures","text":""},{"location":"api/statistics/#spectralmatch.statistics.compare_image_spectral_profiles","title":"<code>compare_image_spectral_profiles(input_image_dict, output_figure_path, title, xlabel, ylabel)</code>","text":"<p>Compares spectral profiles of multiple images by plotting median and interquartile ranges.</p> <p>Parameters:</p> Name Type Description Default <code>input_image_dict</code> <code>dict</code> <p>Mapping of labels to image file paths.</p> required <code>output_figure_path</code> <code>str</code> <p>Path to save the output plot.</p> required <code>title</code> <code>str</code> <p>Title of the plot.</p> required <code>xlabel</code> <code>str</code> <p>Label for the x-axis.</p> required <code>ylabel</code> <code>str</code> <p>Label for the y-axis.</p> required Outputs <p>Saves a spectral profile comparison figure to the specified path.</p> Source code in <code>spectralmatch/statistics.py</code> <pre><code>def compare_image_spectral_profiles(\n    input_image_dict: dict,\n    output_figure_path: str,\n    title: str,\n    xlabel: str,\n    ylabel: str,\n    ):\n    \"\"\"\n    Compares spectral profiles of multiple images by plotting median and interquartile ranges.\n\n    Args:\n        input_image_dict (dict): Mapping of labels to image file paths.\n        output_figure_path (str): Path to save the output plot.\n        title (str): Title of the plot.\n        xlabel (str): Label for the x-axis.\n        ylabel (str): Label for the y-axis.\n\n    Outputs:\n        Saves a spectral profile comparison figure to the specified path.\n    \"\"\"\n\n    plt.figure(figsize=(10, 6))\n    colors = itertools.cycle(plt.cm.tab10.colors)  # Cycle through colors\n    spectral_profiles = []\n    labels = []\n\n    for label, image_path in input_image_dict.items():\n        dataset = gdal.Open(image_path)\n        if dataset is None:\n            print(f\"Failed to open {image_path}\")\n            continue\n\n        image_data = dataset.ReadAsArray()\n        if image_data.ndim == 3:\n            bands, height, width = image_data.shape\n        else:\n            bands, height, width = 1, *image_data.shape\n            image_data = np.expand_dims(image_data, axis=0)\n\n        image_data = image_data.reshape(bands, -1)\n        mean_spectral = np.median(image_data, axis=1)\n        q25, q75 = np.percentile(image_data, [25, 75], axis=1)\n        spectral_profiles.append((mean_spectral, q25, q75))\n        labels.append(label)\n\n    for i, (mean_spectral, q25, q75) in enumerate(spectral_profiles):\n        color = next(colors)  # Assign unique color\n        plt.plot(range(1, len(mean_spectral) + 1), mean_spectral, color=color, label=labels[i])\n        plt.fill_between(range(1, len(mean_spectral) + 1), q25, q75, color=color, alpha=0.3)\n\n    plt.xlabel(xlabel)\n    plt.ylabel(ylabel)\n    plt.title(title)\n    plt.legend()\n    plt.grid(True)\n    plt.savefig(output_figure_path, dpi=300)\n    plt.close()\n    print(f\"Figure saved to: {output_figure_path}\")\n</code></pre>"},{"location":"api/statistics/#spectralmatch.statistics.compare_image_spectral_profiles_pairs","title":"<code>compare_image_spectral_profiles_pairs(image_groups_dict, output_figure_path)</code>","text":"<p>Plots paired spectral profiles for before-and-after image comparisons.</p> <p>Parameters:</p> Name Type Description Default <code>image_groups_dict</code> <code>dict</code> <p>Mapping of labels to image path pairs (before, after).</p> required <code>output_figure_path</code> <code>str</code> <p>Path to save the resulting comparison figure.</p> required Outputs <p>Saves a spectral comparison plot showing pre- and post-processing profiles.</p> Source code in <code>spectralmatch/statistics.py</code> <pre><code>def compare_image_spectral_profiles_pairs(\n    image_groups_dict: dict,\n    output_figure_path: str,\n    ):\n    \"\"\"\n    Plots paired spectral profiles for before-and-after image comparisons.\n\n    Args:\n        image_groups_dict (dict): Mapping of labels to image path pairs (before, after).\n        output_figure_path (str): Path to save the resulting comparison figure.\n\n    Outputs:\n        Saves a spectral comparison plot showing pre- and post-processing profiles.\n    \"\"\"\n\n    plt.figure(figsize=(10, 6))\n    colors = itertools.cycle(plt.cm.tab10.colors)  # Cycle through colors\n\n    for label, group in image_groups_dict.items():\n        if len(group) == 2:  # Ensure paired comparison\n            image_path1, image_path2 = group\n            color = next(colors)  # Assign the same color to both images\n\n            for i, image_path in enumerate([image_path1, image_path2]):\n                with rasterio.open(image_path) as src:\n                    img = src.read()\n                    num_bands = img.shape[0]\n                    img_reshaped = img.reshape(num_bands, -1)\n                    nodata_value = src.nodata\n                    if nodata_value is not None:\n                        img_reshaped = np.where(img_reshaped == nodata_value, np.nan, img_reshaped)\n                    mean_spectral = np.nanmean(img_reshaped, axis=1)\n                    bands = np.arange(1, num_bands + 1)\n                    linestyle = 'dashed' if i == 0 else 'solid'\n                    plt.plot(bands, mean_spectral, linestyle=linestyle, color=color, label=f\"{label} - {'Before' if i == 0 else 'After'}\")\n\n    plt.xlabel(\"Band Number\")\n    plt.ylabel(\"Reflectance(0-10,000)\")\n    plt.title(\"Pre and Post Spectral Match Comparison\")\n    plt.legend()\n    plt.grid(True)\n    plt.savefig(output_figure_path, dpi=300)\n    plt.close()\n    print(f\"Figure saved to: {output_figure_path}\")\n</code></pre>"},{"location":"api/statistics/#spectralmatch.statistics.compare_spatial_spectral_difference_average","title":"<code>compare_spatial_spectral_difference_average(input_overlapping_image_pair_path, output_image_path)</code>","text":"<p>Generates a heatmap of the average spectral difference between two overlapping images.</p> <p>Parameters:</p> Name Type Description Default <code>input_overlapping_image_pair_path</code> <code>list</code> <p>List containing exactly two image paths (pre and post).</p> required <code>output_image_path</code> <code>str</code> <p>Path to save the resulting difference visualization.</p> required Outputs <p>Saves a heatmap image illustrating spatial spectral differences.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the list does not contain exactly two images or if image dimensions differ.</p> Source code in <code>spectralmatch/statistics.py</code> <pre><code>def compare_spatial_spectral_difference_average(\n    input_overlapping_image_pair_path: list,\n    output_image_path: str,\n    ):\n    \"\"\"\n    Generates a heatmap of the average spectral difference between two overlapping images.\n\n    Args:\n        input_overlapping_image_pair_path (list): List containing exactly two image paths (pre and post).\n        output_image_path (str): Path to save the resulting difference visualization.\n\n    Outputs:\n        Saves a heatmap image illustrating spatial spectral differences.\n\n    Raises:\n        ValueError: If the list does not contain exactly two images or if image dimensions differ.\n    \"\"\"\n\n    if len(input_overlapping_image_pair_path) != 2:\n        raise ValueError(\"Function requires exactly two image paths for comparison.\")\n\n    image_path1, image_path2 = input_overlapping_image_pair_path\n\n    with rasterio.open(image_path1) as src1, rasterio.open(image_path2) as src2:\n        img1 = src1.read()  # Read all bands (shape: bands, height, width)\n        img2 = src2.read()\n\n        if img1.shape != img2.shape:\n            raise ValueError(\"Images must have the same dimensions for comparison.\")\n\n        # Compute absolute spectral difference per band\n        diff = np.abs(img2 - img1)\n        mean_diff = np.mean(diff, axis=0)  # Average across bands for visualization\n\n        plt.figure(figsize=(10, 6))\n        plt.imshow(mean_diff, cmap='coolwarm', interpolation='nearest')\n        plt.colorbar(label=\"Spectral Difference\")\n        plt.title(\"Spatial Spectral Difference (Post - Pre)\")\n        plt.axis(\"off\")\n\n        plt.savefig(output_image_path, dpi=300, bbox_inches='tight')\n        plt.close()\n\n    print(f\"Spatial spectral difference figure saved to: {output_image_path}\")\n</code></pre>"},{"location":"api/statistics/#spectralmatch.statistics.compare_spatial_spectral_difference_individual_bands","title":"<code>compare_spatial_spectral_difference_individual_bands(input_overlapping_image_pair_paths, output_image_path)</code>","text":"<p>Creates a color-coded visualization of spectral differences per band between two overlapping images.</p> <p>Parameters:</p> Name Type Description Default <code>input_overlapping_image_pair_paths</code> <code>tuple</code> <p>Tuple of two image paths (before, after).</p> required <code>output_image_path</code> <code>str</code> <p>Path to save the RGB difference visualization as a PNG.</p> required Outputs <p>Saves a PNG image where color represents the dominant band of spectral difference and brightness indicates magnitude.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input images differ in shape.</p> Source code in <code>spectralmatch/statistics.py</code> <pre><code>def compare_spatial_spectral_difference_individual_bands(\n    input_overlapping_image_pair_paths: tuple,\n    output_image_path: str,\n    ):\n    \"\"\"\n    Creates a color-coded visualization of spectral differences per band between two overlapping images.\n\n    Args:\n        input_overlapping_image_pair_paths (tuple): Tuple of two image paths (before, after).\n        output_image_path (str): Path to save the RGB difference visualization as a PNG.\n\n    Outputs:\n        Saves a PNG image where color represents the dominant band of spectral difference and brightness indicates magnitude.\n\n    Raises:\n        ValueError: If input images differ in shape.\n    \"\"\"\n\n    path1, path2 = input_overlapping_image_pair_paths\n    with rasterio.open(path1) as src1, rasterio.open(path2) as src2:\n        img1 = src1.read()  # shape: (num_bands, height, width)\n        img2 = src2.read()  # shape: (num_bands, height, width)\n\n        if img1.shape != img2.shape:\n            raise ValueError(\n                f\"Input images do not have the same shape:\\n\"\n                f\" Image1 shape: {img1.shape}, Image2 shape: {img2.shape}\"\n            )\n\n        num_bands, height, width = img1.shape\n\n    diff = np.abs(img1 - img2).astype(np.float32)  # (bands, height, width)\n\n    global_min = diff.min()  # often 0\n    global_max = diff.max()\n\n    default_colors = [\n        (1.0, 0.0, 0.0),  # Band 1 -&gt; Red\n        (0.0, 1.0, 0.0),  # Band 2 -&gt; Green\n        (0.0, 0.0, 1.0),  # Band 3 -&gt; Blue\n        (1.0, 1.0, 0.0),  # Band 4 -&gt; Yellow\n        (1.0, 0.0, 1.0),  # Band 5 -&gt; Magenta\n        (0.0, 1.0, 1.0),  # Band 6 -&gt; Cyan\n        (1.0, 0.5, 0.0),  # Band 7 -&gt; Orange\n        # etc. Add more if needed\n    ]\n\n    band_colors = [default_colors[i % len(default_colors)] for i in range(num_bands)]\n    band_colors = np.array(band_colors, dtype=np.float32)  # shape: (num_bands, 3)\n\n    # Initialize an empty float array for RGB: shape = (3, height, width)\n    output_rgb = np.zeros((3, height, width), dtype=np.float32)\n\n    # sum of differences per pixel across all bands -&gt; shape: (height, width)\n    sum_diff = diff.sum(axis=0)\n    sum_diff_safe = np.where(sum_diff == 0, 1e-10, sum_diff)  # avoid division-by-zero\n\n    # fraction_diff[b, y, x] = diff[b, y, x] / sum_diff[y, x]\n    fraction_diff = diff / sum_diff_safe\n\n    # Accumulate weighted colors\n    for b in range(num_bands):\n        # band_colors[b] is shape (3,)\n        # fraction_diff[b] is shape (height, width)\n        output_rgb += fraction_diff[b] * band_colors[b].reshape(3, 1, 1)\n\n\n    brightness = (sum_diff - global_min) / (global_max - global_min + 1e-10)\n    brightness = np.clip(brightness, 0.0, 1.0)\n    # Multiply the RGB by brightness\n    output_rgb *= brightness.reshape(1, height, width)\n\n    output_rgb_for_plot = np.transpose(output_rgb, (1, 2, 0))\n\n    # Ensure the data is in 0..1\n    output_rgb_for_plot = np.clip(output_rgb_for_plot, 0, 1)\n\n    # Use plt.imsave to write out a PNG\n    plt.imsave(output_image_path, output_rgb_for_plot)\n\n    print(f\"Saved difference visualization PNG to: {output_image_path}\")\n</code></pre>"},{"location":"examples/benchmark/","title":"Benchmark Mulithreading","text":"In\u00a0[\u00a0]: Copied! <pre>import os, shutil, tempfile, time\nfrom pathlib import Path\n</pre> import os, shutil, tempfile, time from pathlib import Path In\u00a0[\u00a0]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\nimport rasterio\nfrom rasterio.transform import from_origin\n</pre> import matplotlib.pyplot as plt import numpy as np import rasterio from rasterio.transform import from_origin In\u00a0[\u00a0]: Copied! <pre>from spectralmatch import global_regression, local_block_adjustment\n</pre> from spectralmatch import global_regression, local_block_adjustment In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>def make_fake_rasters(out_dir, n_images, width, height, nodata=0):\n    out_dir = Path(out_dir)\n    out_dir.mkdir(parents=True, exist_ok=True)\n    profile = dict(\n        driver=\"GTiff\",\n        width=width,\n        height=height,\n        count=8,\n        dtype=\"uint16\",\n        nodata=nodata,\n        crs=\"EPSG:3857\",\n        transform=from_origin(0, 0, 1, 1),\n        tiled=True,\n        blockxsize=512,\n        blockysize=512,\n        compress=\"LZW\",\n    )\n    rng = np.random.default_rng(seed=42)\n    paths = []\n    for i in range(n_images):\n        p = out_dir / f\"fake_{i+1}_{width}px.tif\"\n        with rasterio.open(p, \"w\", **profile) as dst:\n            for b in range(1, 9):\n                data = rng.integers(1, 1000, size=(height, width), dtype=\"uint16\")\n                data[0, 0] = nodata\n                dst.write(data, indexes=b)\n        paths.append(str(p))\n    return paths\n</pre> def make_fake_rasters(out_dir, n_images, width, height, nodata=0):     out_dir = Path(out_dir)     out_dir.mkdir(parents=True, exist_ok=True)     profile = dict(         driver=\"GTiff\",         width=width,         height=height,         count=8,         dtype=\"uint16\",         nodata=nodata,         crs=\"EPSG:3857\",         transform=from_origin(0, 0, 1, 1),         tiled=True,         blockxsize=512,         blockysize=512,         compress=\"LZW\",     )     rng = np.random.default_rng(seed=42)     paths = []     for i in range(n_images):         p = out_dir / f\"fake_{i+1}_{width}px.tif\"         with rasterio.open(p, \"w\", **profile) as dst:             for b in range(1, 9):                 data = rng.integers(1, 1000, size=(height, width), dtype=\"uint16\")                 data[0, 0] = nodata                 dst.write(data, indexes=b)         paths.append(str(p))     return paths In\u00a0[\u00a0]: Copied! <pre>SIZES = [2_048, 4_096, 6_144, 8_192, 10_240, 12_288]\nNUM_IMAGES = 2\nTILE_SIZE = (1024, 1024)\nMAX_WORKERS = 32\n</pre> SIZES = [2_048, 4_096, 6_144, 8_192, 10_240, 12_288] NUM_IMAGES = 2 TILE_SIZE = (1024, 1024) MAX_WORKERS = 32 In\u00a0[\u00a0]: Copied! <pre>WORK_DIR = Path(__file__).parent / \"bench_output\"\nWORK_DIR.mkdir(exist_ok=True)\n</pre> WORK_DIR = Path(__file__).parent / \"bench_output\" WORK_DIR.mkdir(exist_ok=True) In\u00a0[\u00a0]: Copied! <pre>SERIAL, PARALLEL = [], []\n</pre> SERIAL, PARALLEL = [], [] In\u00a0[\u00a0]: Copied! <pre>for sz in SIZES:\n    print(f\"\\n=== {sz} \u00d7 {sz} px  ({NUM_IMAGES} images) ===\")\n    tmp = Path(tempfile.mkdtemp(prefix=f\"fake_{sz}px_\", dir=WORK_DIR))\n    imgs = make_fake_rasters(tmp, NUM_IMAGES, sz, sz)\n\n    t0 = time.time()\n    g_dir = tmp / \"serial_g\"\n    l_dir = tmp / \"serial_l\"\n\n    global_regression(\n        imgs,\n        g_dir,\n        custom_mean_factor=3,\n        custom_std_factor=1,\n        tile_width_and_height_tuple=TILE_SIZE,\n        parallel=False,\n        debug_mode=False,\n    )\n    glob_imgs = sorted((g_dir / \"Images\").glob(\"*.tif\"))\n\n    local_block_adjustment(\n        [str(p) for p in glob_imgs],\n        l_dir,\n        target_blocks_per_image=100,\n        tile_width_and_height_tuple=TILE_SIZE,\n        custom_nodata_value=-9999,\n        parallel=False,\n        debug_mode=False,\n    )\n    SERIAL.append(time.time() - t0)\n    print(f\"serial   : {SERIAL[-1]:.1f} s\")\n\n    t0 = time.time()\n    g_dir = tmp / \"parallel_g\"\n    l_dir = tmp / \"parallel_l\"\n\n    global_regression(\n        imgs,\n        g_dir,\n        custom_mean_factor=3,\n        custom_std_factor=1,\n        tile_width_and_height_tuple=TILE_SIZE,\n        parallel=True,\n        max_workers=MAX_WORKERS,\n        debug_mode=False,\n    )\n    glob_imgs = sorted((g_dir / \"Images\").glob(\"*.tif\"))\n\n    local_block_adjustment(\n        [str(p) for p in glob_imgs],\n        l_dir,\n        target_blocks_per_image=100,\n        tile_width_and_height_tuple=TILE_SIZE,\n        custom_nodata_value=-9999,\n        parallel=True,\n        max_workers=MAX_WORKERS,\n        debug_mode=False,\n    )\n    PARALLEL.append(time.time() - t0)\n    print(f\"parallel : {PARALLEL[-1]:.1f} s\")\n\n    shutil.rmtree(tmp, ignore_errors=True)\n</pre> for sz in SIZES:     print(f\"\\n=== {sz} \u00d7 {sz} px  ({NUM_IMAGES} images) ===\")     tmp = Path(tempfile.mkdtemp(prefix=f\"fake_{sz}px_\", dir=WORK_DIR))     imgs = make_fake_rasters(tmp, NUM_IMAGES, sz, sz)      t0 = time.time()     g_dir = tmp / \"serial_g\"     l_dir = tmp / \"serial_l\"      global_regression(         imgs,         g_dir,         custom_mean_factor=3,         custom_std_factor=1,         tile_width_and_height_tuple=TILE_SIZE,         parallel=False,         debug_mode=False,     )     glob_imgs = sorted((g_dir / \"Images\").glob(\"*.tif\"))      local_block_adjustment(         [str(p) for p in glob_imgs],         l_dir,         target_blocks_per_image=100,         tile_width_and_height_tuple=TILE_SIZE,         custom_nodata_value=-9999,         parallel=False,         debug_mode=False,     )     SERIAL.append(time.time() - t0)     print(f\"serial   : {SERIAL[-1]:.1f} s\")      t0 = time.time()     g_dir = tmp / \"parallel_g\"     l_dir = tmp / \"parallel_l\"      global_regression(         imgs,         g_dir,         custom_mean_factor=3,         custom_std_factor=1,         tile_width_and_height_tuple=TILE_SIZE,         parallel=True,         max_workers=MAX_WORKERS,         debug_mode=False,     )     glob_imgs = sorted((g_dir / \"Images\").glob(\"*.tif\"))      local_block_adjustment(         [str(p) for p in glob_imgs],         l_dir,         target_blocks_per_image=100,         tile_width_and_height_tuple=TILE_SIZE,         custom_nodata_value=-9999,         parallel=True,         max_workers=MAX_WORKERS,         debug_mode=False,     )     PARALLEL.append(time.time() - t0)     print(f\"parallel : {PARALLEL[-1]:.1f} s\")      shutil.rmtree(tmp, ignore_errors=True) In\u00a0[\u00a0]: Copied! <pre>plt.figure(figsize=(8, 5))\nplt.plot(SIZES, SERIAL, \"-o\", label=\"serial\")\nplt.plot(SIZES, PARALLEL, \"-o\", label=f\"parallel ({MAX_WORKERS} workers)\")\nplt.xlabel(\"Raster width = height (pixels)\")\nplt.ylabel(\"Total runtime: global + local (seconds)\")\nplt.title(\"Pipeline runtime vs. image size (8-band, 2 images)\")\nplt.grid(True)\nplt.legend()\nplt.tight_layout()\nplt.show()\n</pre> plt.figure(figsize=(8, 5)) plt.plot(SIZES, SERIAL, \"-o\", label=\"serial\") plt.plot(SIZES, PARALLEL, \"-o\", label=f\"parallel ({MAX_WORKERS} workers)\") plt.xlabel(\"Raster width = height (pixels)\") plt.ylabel(\"Total runtime: global + local (seconds)\") plt.title(\"Pipeline runtime vs. image size (8-band, 2 images)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show()"},{"location":"examples/calculate_statistics/","title":"Calculate Statistics for Figures","text":"In\u00a0[\u00a0]: Copied! <pre>from spectralmatch import (\n    compare_spatial_spectral_difference_individual_bands,\n    compare_image_spectral_profiles_pairs,\n    compare_image_spectral_profiles,\n    compare_spatial_spectral_difference_average)\n</pre> from spectralmatch import (     compare_spatial_spectral_difference_individual_bands,     compare_image_spectral_profiles_pairs,     compare_image_spectral_profiles,     compare_spatial_spectral_difference_average) In\u00a0[\u00a0]: Copied! <pre>compare_spatial_spectral_difference_individual_bands(\n    (\n    '/image/a.tif',\n    '/image/b.tif'),\n    '/output.png'\n)\n</pre> compare_spatial_spectral_difference_individual_bands(     (     '/image/a.tif',     '/image/b.tif'),     '/output.png' ) In\u00a0[\u00a0]: Copied! <pre>compare_image_spectral_profiles_pairs(\n    {\n        'Image A': [\n            '/image/before/a.tif',\n            'image/after/a.tif'\n        ],\n        'Image B': [\n            '/image/before/b.tif',\n            '/image/after/b.tif'\n        ]\n    },\n    '/output.png'\n)\n</pre> compare_image_spectral_profiles_pairs(     {         'Image A': [             '/image/before/a.tif',             'image/after/a.tif'         ],         'Image B': [             '/image/before/b.tif',             '/image/after/b.tif'         ]     },     '/output.png' ) In\u00a0[\u00a0]: Copied! <pre>compare_image_spectral_profiles(\n    {\n        'Image A': 'image/a.tif',\n        'Image B': '/image/b.tif'\n    },\n    \"/output.png\",\n    \"Digital Number Spectral Profile Comparison\",\n    'Band',\n    'Digital Number(0-2,047)',\n</pre> compare_image_spectral_profiles(     {         'Image A': 'image/a.tif',         'Image B': '/image/b.tif'     },     \"/output.png\",     \"Digital Number Spectral Profile Comparison\",     'Band',     'Digital Number(0-2,047)', In\u00a0[\u00a0]: Copied! <pre>)\n</pre> ) In\u00a0[\u00a0]: Copied! <pre>compare_spatial_spectral_difference_average(\n    [\n        '/image/a.tif',\n        '/image/a.tif'\n     ],\n    '/output.png'\n)\n</pre> compare_spatial_spectral_difference_average(     [         '/image/a.tif',         '/image/a.tif'      ],     '/output.png' )"},{"location":"examples/example_global_to_local/","title":"Match: Global to Local","text":"In\u00a0[\u00a0]: Copied! <pre>import os\n</pre> import os In\u00a0[\u00a0]: Copied! <pre>from spectralmatch import global_regression, local_block_adjustment\nfrom spectralmatch import merge_rasters\n</pre> from spectralmatch import global_regression, local_block_adjustment from spectralmatch import merge_rasters In\u00a0[\u00a0]: Copied! <pre># -------------------- Parameters\nworking_directory = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"example_data\")\n# This script is setup to perform matching on all tif files from a folder within the working directory called \"input\" e.g. working_directory/input/*.tif.\n</pre> # -------------------- Parameters working_directory = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"example_data\") # This script is setup to perform matching on all tif files from a folder within the working directory called \"input\" e.g. working_directory/input/*.tif. In\u00a0[\u00a0]: Copied! <pre>vector_mask_path = working_directory + \"/Input/Masks.gpkg\"\n</pre> vector_mask_path = working_directory + \"/Input/Masks.gpkg\" In\u00a0[\u00a0]: Copied! <pre>input_folder = os.path.join(working_directory, \"Input\")\nglobal_folder = os.path.join(working_directory, \"Output/GlobalMatch\")\nlocal_folder = os.path.join(working_directory, \"Output/LocalMatch\")\n</pre> input_folder = os.path.join(working_directory, \"Input\") global_folder = os.path.join(working_directory, \"Output/GlobalMatch\") local_folder = os.path.join(working_directory, \"Output/LocalMatch\") In\u00a0[\u00a0]: Copied! <pre># -------------------- Global histogram matching\ninput_image_paths_array = [os.path.join(input_folder, f) for f in os.listdir(input_folder) if f.lower().endswith(\".tif\")]\n</pre> # -------------------- Global histogram matching input_image_paths_array = [os.path.join(input_folder, f) for f in os.listdir(input_folder) if f.lower().endswith(\".tif\")] In\u00a0[\u00a0]: Copied! <pre>matched_global_images_paths = global_regression(\n    input_image_paths_array,\n    global_folder,\n    custom_mean_factor = 3, # Defualt 1; 3 often works better to 'move' the spectral mean of images closer together\n    custom_std_factor = 1,\n    # vector_mask_path=vector_mask_path,\n    debug_mode=False,\n    tile_width_and_height_tuple=(512, 512),\n    parallel=True,\n    custom_nodata_value=-9999,\n    )\n</pre> matched_global_images_paths = global_regression(     input_image_paths_array,     global_folder,     custom_mean_factor = 3, # Defualt 1; 3 often works better to 'move' the spectral mean of images closer together     custom_std_factor = 1,     # vector_mask_path=vector_mask_path,     debug_mode=False,     tile_width_and_height_tuple=(512, 512),     parallel=True,     custom_nodata_value=-9999,     ) In\u00a0[\u00a0]: Copied! <pre>merge_rasters(\n    matched_global_images_paths, # Rasters are layered with the last ones on top\n    os.path.join(working_directory, \"Output/GlobalMatch/MatchedGlobalImages.tif\"),\n    tile_width_and_height_tuple=(512, 512),\n    )\n</pre> merge_rasters(     matched_global_images_paths, # Rasters are layered with the last ones on top     os.path.join(working_directory, \"Output/GlobalMatch/MatchedGlobalImages.tif\"),     tile_width_and_height_tuple=(512, 512),     ) In\u00a0[\u00a0]: Copied! <pre># -------------------- Local histogram matching\nglobal_image_paths_array = [os.path.join(f\"{global_folder}/Images\", f) for f in os.listdir(f\"{global_folder}/Images\") if f.lower().endswith(\".tif\")]\n</pre> # -------------------- Local histogram matching global_image_paths_array = [os.path.join(f\"{global_folder}/Images\", f) for f in os.listdir(f\"{global_folder}/Images\") if f.lower().endswith(\".tif\")] In\u00a0[\u00a0]: Copied! <pre>matched_local_images_paths = local_block_adjustment(\n    global_image_paths_array,\n    local_folder,\n    target_blocks_per_image=100,\n    projection=\"EPSG:6635\",\n    debug_mode=False,\n    tile_width_and_height_tuple=(512, 512),\n    parallel=True,\n    custom_nodata_value=-9999,\n    )\n</pre> matched_local_images_paths = local_block_adjustment(     global_image_paths_array,     local_folder,     target_blocks_per_image=100,     projection=\"EPSG:6635\",     debug_mode=False,     tile_width_and_height_tuple=(512, 512),     parallel=True,     custom_nodata_value=-9999,     ) In\u00a0[\u00a0]: Copied! <pre>merge_rasters(\n    matched_local_images_paths, # Rasters are layered with the last ones on top\n    os.path.join(working_directory, \"Output/LocalMatch/MatchedLocalImages.tif\"),\n    tile_width_and_height_tuple=(512, 512),\n    )\n</pre> merge_rasters(     matched_local_images_paths, # Rasters are layered with the last ones on top     os.path.join(working_directory, \"Output/LocalMatch/MatchedLocalImages.tif\"),     tile_width_and_height_tuple=(512, 512),     ) In\u00a0[\u00a0]: Copied! <pre>print(\"Done with global and local histogram matching\")\n</pre> print(\"Done with global and local histogram matching\")"},{"location":"examples/mask_cloud/","title":"Create Cloud Mask","text":"In\u00a0[\u00a0]: Copied! <pre>from spectralmatch import (\n    create_cloud_mask_with_omnicloudmask,\n    post_process_raster_cloud_mask_to_vector,\n)\n</pre> from spectralmatch import (     create_cloud_mask_with_omnicloudmask,     post_process_raster_cloud_mask_to_vector, ) In\u00a0[\u00a0]: Copied! <pre>from spectralmatch import write_vector\n</pre> from spectralmatch import write_vector In\u00a0[\u00a0]: Copied! <pre>create_cloud_mask_with_omnicloudmask(\n    \"input_image_path.tif\",\n    5,\n    3,\n    8,\n    \"output_mask&gt;path.tif\",\n    down_sample_m=10\n)\nwrite_vector(\n    post_process_raster_cloud_mask_to_vector(\n        \"input_image_path.tif\",\n        None,\n        {1: 50},\n        {0: 0, 1: 1, 2: 1, 3: 1}\n    ),\n    \"output_vector_path.tif\",\n)\n</pre> create_cloud_mask_with_omnicloudmask(     \"input_image_path.tif\",     5,     3,     8,     \"output_mask&gt;path.tif\",     down_sample_m=10 ) write_vector(     post_process_raster_cloud_mask_to_vector(         \"input_image_path.tif\",         None,         {1: 50},         {0: 0, 1: 1, 2: 1, 3: 1}     ),     \"output_vector_path.tif\", )"},{"location":"examples/mask_ndvi/","title":"Create Vegetation Mask","text":"In\u00a0[\u00a0]: Copied! <pre>from spectralmatch import (\n    create_ndvi_mask,\n    post_process_threshold_to_vector\n)\n</pre> from spectralmatch import (     create_ndvi_mask,     post_process_threshold_to_vector ) In\u00a0[\u00a0]: Copied! <pre>create_ndvi_mask(\n    \"input_image_path.tif\",\n    \"output_image_path.tif\",\n    4,\n    3,\n)\npost_process_threshold_to_vector(\n    \"input_image_path.tif\",\n    'output_vector_path.gpkg',\n    0.2,\n    \"&lt;=\",\n)\n</pre> create_ndvi_mask(     \"input_image_path.tif\",     \"output_image_path.tif\",     4,     3, ) post_process_threshold_to_vector(     \"input_image_path.tif\",     'output_vector_path.gpkg',     0.2,     \"&lt;=\", )"}]}